name: CD - Provision and Deploy

on:
  push:
    branches: [ "main" ]

env:
  REGISTRY: ${{ secrets.ACR_LOGIN_SERVER }}
  BACKEND_IMAGE_NAME: vote-app
  FRONTEND_IMAGE_NAME: frontend-app
  RESOURCE_GROUP: sit722vote-rg
  CLUSTER_NAME: sit722vote-aks
  MONITORING_NAMESPACE: monitoring

jobs:
  deploy:
    name: Deploy to AKS
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Step 1: Provision the core infrastructure using OpenTofu
      - name: Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
      - name: Tofu Init, Plan and Apply
        working-directory: ./opentofu
        run: |
          tofu init
          tofu apply -auto-approve

      - name: Set AKS Context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ env.RESOURCE_GROUP }}
          cluster-name: ${{ env.CLUSTER_NAME }}

      # Step 2: Deploy Prometheus & Grafana for monitoring
      - name: Install Helm
        uses: azure/setup-helm@v3
      - name: Add Helm Repos and Deploy Monitoring Stack
        run: |
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo update
          # Install if it doesn't exist, otherwise upgrade
          helm upgrade --install prometheus prometheus-community/kube-prometheus-stack --namespace ${{ env.MONITORING_NAMESPACE }} --create-namespace

      # Step 3: Deploy ONLY the backend application
      - name: Deploy Backend App to AKS
        run: |
          # Dynamically replace the backend image tag in its deployment file
          sed -i 's|image: .*|image: ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }}|g' k8s/deployment.yaml
          
          echo "Applying backend manifests..."
          kubectl apply -f k8s/deployment.yaml
          kubectl apply -f k8s/service.yaml
          kubectl apply -f k8s/hpa.yaml

      # Step 4: Wait for the backend to get a public IP and capture it
      - name: Wait for Backend External IP
        id: get_backend_ip # Give this step an ID to reference its output
        run: |
          echo "Waiting for backend service to get an external IP..."
          for i in {1..30}; do # Loop for up to 5 minutes (30 * 10s)
            BACKEND_IP=$(kubectl get service vote-app-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "")
            if [[ -n "$BACKEND_IP" ]]; then
              echo "Backend IP found: $BACKEND_IP"
              # Set the IP as an output of this step
              echo "ip=$BACKEND_IP" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            echo "Attempt $i/30: IP not available yet. Waiting 10 seconds..."
            sleep 10
          done
          echo "Error: Timed out waiting for backend service external IP."
          exit 1
      
      # Step 5: Inject IP, then build and push the frontend image
      - name: Inject Backend IP and Build/Push Frontend
        run: |
          BACKEND_URL="http://${{ steps.get_backend_ip.outputs.ip }}"
          echo "Injecting backend URL into frontend: $BACKEND_URL"
          
          # Use sed to replace the placeholder in the JavaScript file
          sed -i "s|___BACKEND_API_URL___|$BACKEND_URL|g" frontend/script.js
          
          echo "Logging into ACR..."
          docker login ${{ env.REGISTRY }} -u ${{ secrets.ACR_USERNAME }} -p ${{ secrets.ACR_PASSWORD }}
          
          echo "Building and pushing the configured frontend image..."
          docker build ./frontend -t $REGISTRY/$FRONTEND_IMAGE_NAME:${{ github.sha }}
          docker push $REGISTRY/$FRONTEND_IMAGE_NAME:${{ github.sha }}

      # Step 6: Deploy the now-configured frontend application
      - name: Deploy Frontend App to AKS
        run: |
          # Dynamically replace the frontend image tag in its deployment file
          sed -i 's|image: .*|image: ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }}|g' k8s/frontend-deployment.yaml

          echo "Applying frontend manifests..."
          kubectl apply -f k8s/frontend-deployment.yaml
          kubectl apply -f k8s/frontend-service.yaml