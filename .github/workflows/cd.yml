name: CD - Provision and Deploy

on:
  push:
    branches: [ "main" ]

env:
  # The env block now uses secrets for all configuration
  REGISTRY: ${{ secrets.ACR_NAME }}.azurecr.io
  BACKEND_IMAGE_NAME: vote-app
  FRONTEND_IMAGE_NAME: frontend-app
  RESOURCE_GROUP: ${{ secrets.RESOURCE_GROUP }}
  CLUSTER_NAME: ${{ secrets.CLUSTER_NAME }}
  MONITORING_NAMESPACE: monitoring

jobs:
  deploy:
    name: Deploy to AKS
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Step 1: Provision Infrastructure with OpenTofu
      - name: Setup OpenTofu
        uses: opentofu/setup-opentofu@v1
      
      - name: Tofu Init, Plan and Apply
        working-directory: ./opentofu
        # This 'env' block passes our GitHub Secrets to OpenTofu
        env:
          TF_VAR_resource_group_name: ${{ secrets.RESOURCE_GROUP }}
          TF_VAR_cluster_name: ${{ secrets.CLUSTER_NAME }}
          TF_VAR_acr_name: ${{ secrets.ACR_NAME }}
        run: |
          tofu init
          # We no longer need to run import, 'apply' will handle it.
          tofu apply -auto-approve

      - name: Set AKS Context
        uses: azure/aks-set-context@v4
        with:
          # These values now come from the secrets
          resource-group: ${{ secrets.RESOURCE_GROUP }}
          cluster-name: ${{ secrets.CLUSTER_NAME }}

      # (Steps for Helm/Monitoring are unchanged)
      - name: Install Helm
        uses: azure/setup-helm@v3
      - name: Add Helm Repos and Deploy Monitoring Stack
        run: |
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo update
          helm upgrade --install prometheus prometheus-community/kube-prometheus-stack --namespace ${{ env.MONITORING_NAMESPACE }} --create-namespace

      # (The rest of the deployment steps are unchanged, as they use the top-level 'env' variables)
      - name: Deploy Backend App to AKS
        run: |
          sed -i 's|image: .*|image: ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }}|g' k8s/deployment.yaml
          kubectl apply -f k8s/deployment.yaml
          kubectl apply -f k8s/service.yaml
          kubectl apply -f k8s/hpa.yaml

      - name: Wait for Backend External IP
        id: get_backend_ip
        run: |
          echo "Waiting for backend service to get an external IP..."
          for i in {1..30}; do
            BACKEND_IP=$(kubectl get service vote-app-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "")
            if [[ -n "$BACKEND_IP" ]]; then
              echo "Backend IP found: $BACKEND_IP"
              echo "ip=$BACKEND_IP" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            sleep 10
          done
          echo "Error: Timed out waiting for backend service external IP."
          exit 1
      
      - name: Inject Backend IP and Build/Push Frontend
        run: |
          BACKEND_URL="http://${{ steps.get_backend_ip.outputs.ip }}"
          sed -i "s|___BACKEND_API_URL___|$BACKEND_URL|g" frontend/script.js
          docker login ${{ env.REGISTRY }} -u ${{ secrets.ACR_NAME }} -p ${{ secrets.ACR_PASSWORD }}
          docker build ./frontend -t $REGISTRY/$FRONTEND_IMAGE_NAME:${{ github.sha }}
          docker push $REGISTRY/$FRONTEND_IMAGE_NAME:${{ github.sha }}

      - name: Deploy Frontend App to AKS
        run: |
          sed -i 's|image: .*|image: ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }}|g' k8s/frontend-deployment.yaml
          kubectl apply -f k8s/frontend-deployment.yaml
          kubectl apply -f k8s/frontend-service.yaml